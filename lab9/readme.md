# Лабораторная работа №9  

## Что такое `null`?

`null` — это специальное значение, обозначающее *отсутствие ссылки* (адреса).  
В памяти представляется как `0`.

---

## Почему тип `int` не позволяет значение `null`?

`int` — это **тип-значение**, а не ссылочный тип.  
Он всегда содержит число.  
`0` — это число, а не отсутствие значения.

---

## Что означает `string?`

`string` — это ссылочный тип.

- `string` - переменная **должна** ссылаться на строку (или выдать предупреждение).
- `string?` - переменная может принимать `null`.

---

## Почему `int?` и `string?` работают по-разному? Как вообще работает `int?`?

Типы `string?` и `int?` оба позволяют хранить значение `null`, но делают это по-разному, потому что относятся к разным категориям типов в C#.

### `string?`: ссылочный тип

`string` — ссылочный тип. Это означает, что переменная хранит **адрес** объекта в памяти.

У ссылочного типа уже существует естественное “пустое” значение — это **нулевая ссылка**, то есть адрес, который указывает «в никуда». Это и есть `null`.

Поэтому:

- `string` может быть `null` технически всегда,
- `string?` просто включает строгую проверку компилятора и заставляет учитывать возможность null.

**Никаких дополнительных структур не создаётся.**

### `int?`: значимый тип

`int` — это **значимый тип**, он хранит само число прямо внутри переменной.
У таких типов нет способа естественным образом представить отсутствие значения — число `0` является валидным значением и не может означать `null`.

Чтобы дать значимым типам возможность хранить `null`, C# использует специальную структуру:

```
Nullable<int>
```

Она содержит:

1. **Значение** (`int`)
2. **Флаг HasValue** (`bool`), который показывает, есть ли значение или это `null`.

То есть `int?` — это по сути контейнер с двумя полями:

- `Value` - хранит само число
- `HasValue` - показывает, является ли значение null

Если `HasValue == false`, переменная считается равной `null`.

`string?` - работает с уже существующим механизмом `null`, встроенным для ссылочных типов.

`int?` - превращается в `Nullable<int>`, который хранит само число плюс флаг, указывающий, есть ли значение.

---

## Что делает оператор `!`?

Оператор `!` называется **null-forgiving operator**. Он позволяет отключить проверку `nullability` для конкретного выражения.
Он сообщает компилятору C#, что выражение **точно не будет null**, даже если статический анализ предупреждает об обратном.

### Зачем он нужен?

Иногда компилятор не может определить, что значение гарантированно не `null`, хотя программист *знает это по логике программы*.

Пример:

```csharp
static string? MaybeString(int num)
{
    if (num == 0)
        return "Hello";
    else
        return null;
}

string s = MaybeString(0)!;
```

Компилятор предупреждает, что `MaybeString` может вернуть `null`.
Но мы **знаем**, что при `num == 0` это невозможно.
Поэтому `!` подавляет предупреждение.

Главное: что делает оператор `!` фактически:

- **На этапе компиляции:** убирает предупреждение о возможном null.
- **На этапе выполнения:** **ничего не делает**.
- Если значение всё-таки окажется null → программа упадёт с `NullReferenceException`.

---

## Пример обхода nullability через `!`

```csharp
string s = MaybeString(1)!; // возвращает null, но ошибки нет
```

Или:

```csharp
string s = null!;
```

То есть можно *сломать* гарантии компилятора.

---

## Что позволяет достичь `required`?

`required` позволяет гарантировать, что гарантии `nullability` компилятора будут всегда соблюдены.
